---
layout: post
title: "[백준] 12100번 2048(easy) - C++"
subtitle: "브루트 포스, 구현"
date: 2020-11-06 14:49:00
author: "dongjune"
header-img: "img/in_post/code-bg.jpg"
catalog: true
tags:
  - BOJ
---

# 문제
[12100번 2048(easy)](https://www.acmicpc.net/problem/12100){:target="_blank"}
# 풀이
2048 게임을 구현하는 문제로 로직은 간단했지만 구현에 시간이 오래 걸리는 문제였다.  
1. board의 숫자를 움직이는 left, right, up, down 함수를 만들어준다.
2. dfs를 통해 5번 이동 하는 모든 경우의 수를 탐색하며 최대값을 갱신해준다. 최대 값 갱신은 getMax 함수를 만들어서 수행했다.

가장 중요한 부분이 **left, right, up, down** 함수를 만드는 것이었다. 여기서 주의 할 점은 한번 움직일 때 합쳐진 타일은 다른 타일과 다시 합쳐질 수 없다는 것이다. 이 부분을 위해 2차원 check 벡터를 만들어서 합쳐진 적이 있는지 체크 해 줬다.
```c++
vector<vector<bool>> check(n, vector<bool>(n, false));
```   
   
그 후 dfs를 통해 5번 이동하는 모든 경우의 수를 탐색해 줬다.
```c++
void dfs(int L, vector<vector<ll>> board)
{
    // 최대 값 갱신
    ans = max(ans, getMax(board));
    // 5번 이동한 경우 return
    if (L == 5)
        return;
    dfs(L + 1, right(board)); // 오른쪽 이동
    dfs(L + 1, left(board)); // 왼쪽 이동
    dfs(L + 1, up(board)); // 위로 이동
    dfs(L + 1, down(board)); // 아래로 이동
}
```


# 소스 코드
```c++
#include <iostream>
#include <vector>
#define max(a, b) a > b ? a : b

using namespace std;
typedef long long ll;

int n;
ll ans;

// board에서 최대 값 구하는 함수
ll getMax(vector<vector<ll>> board)
{
    ll res = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            res = max(res, board[i][j]);
        }
    }
    return res;
}

// 오른쪽 이동
vector<vector<ll>> right(vector<vector<ll>> board)
{
    vector<vector<bool>> check(n, vector<bool>(n, false));

    for (int i = 0; i < n; i++)
    {
        for (int j = n - 2; j >= 0; j--)
        {
            if (board[i][j] == 0)
                continue;
            for (int k = j + 1; k < n; k++)
            {
                if (board[i][k] == board[i][k - 1] && !check[i][k])
                {
                    board[i][k] *= 2;
                    board[i][k - 1] = 0;
                    check[i][k] = true;
                    break;
                }
                else if (board[i][k] == 0)
                {
                    board[i][k] = board[i][k - 1];
                    board[i][k - 1] = 0;
                }
                else
                {
                    break;
                }
            }
        }
    }
    return board;
}

// 왼쪽 이동
vector<vector<ll>> left(vector<vector<ll>> board)
{
    vector<vector<bool>> check(n, vector<bool>(n, false));

    for (int i = 0; i < n; i++)
    {
        for (int j = 1; j < n; j++)
        {
            if (board[i][j] == 0)
                continue;
            for (int k = j - 1; k >= 0; k--)
            {
                if (board[i][k] == board[i][k + 1] && !check[i][k])
                {
                    board[i][k] *= 2;
                    board[i][k + 1] = 0;
                    check[i][k] = true;
                    break;
                }
                else if (board[i][k] == 0)
                {
                    board[i][k] = board[i][k + 1];
                    board[i][k + 1] = 0;
                }
                else
                {
                    break;
                }
            }
        }
    }
    return board;
}

// 아래 이동
vector<vector<ll>> down(vector<vector<ll>> board)
{
    vector<vector<bool>> check(n, vector<bool>(n, false));

    for (int i = 0; i < n; i++)
    {
        for (int j = n - 2; j >= 0; j--)
        {
            if (board[j][i] == 0)
                continue;
            for (int k = j + 1; k < n; k++)
            {
                if (board[k][i] == board[k - 1][i] && !check[k][i])
                {
                    board[k][i] *= 2;
                    board[k - 1][i] = 0;
                    check[k][i] = true;
                    break;
                }
                else if (board[k][i] == 0)
                {
                    board[k][i] = board[k - 1][i];
                    board[k - 1][i] = 0;
                }
                else
                {
                    break;
                }
            }
        }
    }
    return board;
}

// 위로 이동
vector<vector<ll>> up(vector<vector<ll>> board)
{
    vector<vector<bool>> check(n, vector<bool>(n, false));

    for (int i = 0; i < n; i++)
    {
        for (int j = 1; j < n; j++)
        {
            if (board[j][i] == 0)
                continue;
            for (int k = j - 1; k >= 0; k--)
            {
                if (board[k][i] == board[k + 1][i] && !check[k][i])
                {
                    board[k][i] *= 2;
                    board[k + 1][i] = 0;
                    check[k][i] = true;
                    break;
                }
                else if (board[k][i] == 0)
                {
                    board[k][i] = board[k + 1][i];
                    board[k + 1][i] = 0;
                }
                else
                {
                    break;
                }
            }
        }
    }
    return board;
}

void dfs(int L, vector<vector<ll>> board)
{
    ans = max(ans, getMax(board));
    if (L == 5)
        return;
    dfs(L + 1, right(board));
    dfs(L + 1, left(board));
    dfs(L + 1, up(board));
    dfs(L + 1, down(board));
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    // 입력
    cin >> n;
    vector<vector<ll>> board(n, vector<ll>(n));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> board[i][j];
        }
    }

    // dfs 실행
    dfs(0, board);
    cout << ans << '\n';

    return 0;
}
```